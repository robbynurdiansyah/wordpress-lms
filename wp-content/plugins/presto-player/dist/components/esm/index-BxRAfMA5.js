const NAMESPACE="web-components",BUILD={hydratedSelectorName:"hydrated",lazyLoad:!0,slotRelocation:!0,updatable:!0},globalScripts=()=>{},globalStyles=":host{box-sizing:border-box}:host *,:host *:before,:host *:after{box-sizing:inherit}";var __defProp=Object.defineProperty,__export=(e,t)=>{for(var n in t)__defProp(e,n,{get:t[n],enumerable:!0})},SVG_NS="http://www.w3.org/2000/svg",HTML_NS="http://www.w3.org/1999/xhtml",getHostRef=e=>{if(e.__stencil__getHostRef)return e.__stencil__getHostRef()},registerInstance=(e,t)=>{e.__stencil__getHostRef=()=>t,t.$lazyInstance$=e},registerHost=(e,t)=>{const n={$flags$:0,$hostElement$:e,$cmpMeta$:t,$instanceValues$:new Map};n.$onInstancePromise$=new Promise(e=>n.$onInstanceResolve$=e),n.$onReadyPromise$=new Promise(e=>n.$onReadyResolve$=e),e["s-p"]=[],e["s-rc"]=[];const s=n;return e.__stencil__getHostRef=()=>s,s},isMemberInElement=(e,t)=>t in e,consoleError=(e,t)=>(0,console.error)(e,t),cmpModules=new Map,loadModule=(e,t,n)=>{const s=e.$tagName$.replace(/-/g,"_"),o=e.$lazyBundleId$;if(!o)return;const l=cmpModules.get(o);return l?l[s]:import(`./${o}.entry.js`).then(e=>(cmpModules.set(o,e),e[s]),e=>{consoleError(e,t.$hostElement$)})},styles=new Map,HYDRATED_CSS="{visibility:hidden}.hydrated{visibility:inherit}",SLOT_FB_CSS="slot-fb{display:contents}slot-fb[hidden]{display:none}",XLINK_NS="http://www.w3.org/1999/xlink",win="undefined"!=typeof window?window:{},plt={$flags$:0,$resourcesUrl$:"",jmp:e=>e(),raf:e=>requestAnimationFrame(e),ael:(e,t,n,s)=>e.addEventListener(t,n,s),rel:(e,t,n,s)=>e.removeEventListener(t,n,s),ce:(e,t)=>new CustomEvent(e,t)},supportsListenerOptions=(()=>{var e;let t=!1;try{null==(e=win.document)||e.addEventListener("e",null,Object.defineProperty({},"passive",{get(){t=!0}}))}catch(e){}return t})(),promiseResolve=e=>Promise.resolve(e),supportsConstructableStylesheets=(()=>{try{return new CSSStyleSheet,"function"==typeof(new CSSStyleSheet).replaceSync}catch(e){}return!1})(),supportsMutableAdoptedStyleSheets=!!supportsConstructableStylesheets&&(()=>!!win.document&&Object.getOwnPropertyDescriptor(win.document.adoptedStyleSheets,"length").writable)(),queuePending=!1,queueDomReads=[],queueDomWrites=[],queueTask=(e,t)=>n=>{e.push(n),queuePending||(queuePending=!0,t&&4&plt.$flags$?nextTick(flush):plt.raf(flush))},consume=e=>{for(let t=0;t<e.length;t++)try{e[t](performance.now())}catch(e){consoleError(e)}e.length=0},flush=()=>{consume(queueDomReads),consume(queueDomWrites),(queuePending=queueDomReads.length>0)&&plt.raf(flush)},nextTick=e=>promiseResolve().then(e),writeTask=queueTask(queueDomWrites,!0),isComplexType=e=>"object"==(e=typeof e)||"function"===e;function queryNonceMetaTagContent(e){var t,n,s;return null!=(s=null==(n=null==(t=e.head)?void 0:t.querySelector('meta[name="csp-nonce"]'))?void 0:n.getAttribute("content"))?s:void 0}var escapeRegExpSpecialCharacters=e=>e.replace(/[.*+?^${}()|[\]\\]/g,"\\$&"),result_exports={};__export(result_exports,{err:()=>err,map:()=>map,ok:()=>ok,unwrap:()=>unwrap,unwrapErr:()=>unwrapErr});var ok=e=>({isOk:!0,isErr:!1,value:e}),err=e=>({isOk:!1,isErr:!0,value:e});function map(e,t){if(e.isOk){const n=t(e.value);return n instanceof Promise?n.then(e=>ok(e)):ok(n)}if(e.isErr){const t=e.value;return err(t)}throw"should never get here"}var globalStyleSheet,unwrap=e=>{if(e.isOk)return e.value;throw e.value},unwrapErr=e=>{if(e.isErr)return e.value;throw e.value};function createStyleSheetIfNeededAndSupported(e){if(!supportsConstructableStylesheets)return;const t=new CSSStyleSheet;return t.replaceSync(e),t}function createShadowRoot(e){var t;const n=this.attachShadow({mode:"open"});void 0===globalStyleSheet&&(globalStyleSheet=null!=(t=createStyleSheetIfNeededAndSupported(globalStyles))?t:null),globalStyleSheet&&(supportsMutableAdoptedStyleSheets?n.adoptedStyleSheets.push(globalStyleSheet):n.adoptedStyleSheets=[...n.adoptedStyleSheets,globalStyleSheet])}var updateFallbackSlotVisibility=e=>{const t=internalCall(e,"childNodes");e.tagName&&e.tagName.includes("-")&&e["s-cr"]&&"SLOT-FB"!==e.tagName&&getHostSlotNodes(t,e.tagName).forEach(e=>{1===e.nodeType&&"SLOT-FB"===e.tagName&&(getSlotChildSiblings(e,getSlotName(e),!1).length?e.hidden=!0:e.hidden=!1)});let n=0;for(n=0;n<t.length;n++){const e=t[n];1===e.nodeType&&internalCall(e,"childNodes").length&&updateFallbackSlotVisibility(e)}},getSlottedChildNodes=e=>{const t=[];for(let n=0;n<e.length;n++){const s=e[n]["s-nr"]||void 0;s&&s.isConnected&&t.push(s)}return t};function getHostSlotNodes(e,t,n){let s,o=0,l=[];for(;o<e.length;o++)s=e[o],!s["s-sr"]||t&&s["s-hn"]!==t||void 0!==n||l.push(s),l=[...l,...getHostSlotNodes(s.childNodes,t,n)];return l}var getSlotChildSiblings=(e,t,n=!0)=>{const s=[];(n&&e["s-sr"]||!e["s-sr"])&&s.push(e);let o=e;for(;o=o.nextSibling;)getSlotName(o)!==t||!n&&o["s-sr"]||s.push(o);return s},isNodeLocatedInSlot=(e,t)=>1===e.nodeType?null===e.getAttribute("slot")&&""===t||e.getAttribute("slot")===t:e["s-sn"]===t||""===t,getSlotName=e=>"string"==typeof e["s-sn"]?e["s-sn"]:1===e.nodeType&&e.getAttribute("slot")||void 0;function patchSlotNode(e){if(e.assignedElements||e.assignedNodes||!e["s-sr"])return;const t=t=>function(e){const n=[],s=this["s-sn"];(null==e?void 0:e.flatten)&&console.error("\n          Flattening is not supported for Stencil non-shadow slots.\n          You can use `.childNodes` to nested slot fallback content.\n          If you have a particular use case, please open an issue on the Stencil repo.\n        ");const o=this["s-cr"].parentElement;return(o.__childNodes?o.childNodes:getSlottedChildNodes(o.childNodes)).forEach(e=>{s===getSlotName(e)&&n.push(e)}),t?n.filter(e=>1===e.nodeType):n}.bind(e);e.assignedElements=t(!0),e.assignedNodes=t(!1)}function internalCall(e,t){if("__"+t in e){const n=e["__"+t];return"function"!=typeof n?n:n.bind(e)}return"function"!=typeof e[t]?e[t]:e[t].bind(e)}var createTime=(e,t="")=>()=>{},uniqueTime=(e,t)=>()=>{},rootAppliedStyles=new WeakMap,registerStyle=(e,t,n)=>{let s=styles.get(e);supportsConstructableStylesheets&&n?(s=s||new CSSStyleSheet,"string"==typeof s?s=t:s.replaceSync(t)):s=t,styles.set(e,s)},addStyle=(e,t,n)=>{var s;const o=getScopeId(t),l=styles.get(o);if(!win.document)return o;if(e=11===e.nodeType?e:win.document,l)if("string"==typeof l){e=e.head||e;let n,a=rootAppliedStyles.get(e);if(a||rootAppliedStyles.set(e,a=new Set),!a.has(o)){{n=win.document.createElement("style"),n.innerHTML=l;const o=null!=(s=plt.$nonce$)?s:queryNonceMetaTagContent(win.document);if(null!=o&&n.setAttribute("nonce",o),!(1&t.$flags$))if("HEAD"===e.nodeName){const t=e.querySelectorAll("link[rel=preconnect]"),s=t.length>0?t[t.length-1].nextSibling:e.querySelector("style");e.insertBefore(n,(null==s?void 0:s.parentNode)===e?s:null)}else if("host"in e)if(supportsConstructableStylesheets){const t=new CSSStyleSheet;t.replaceSync(l),supportsMutableAdoptedStyleSheets?e.adoptedStyleSheets.unshift(t):e.adoptedStyleSheets=[t,...e.adoptedStyleSheets]}else{const t=e.querySelector("style");t?t.innerHTML=l+t.innerHTML:e.prepend(n)}else e.append(n);1&t.$flags$&&e.insertBefore(n,null)}4&t.$flags$&&(n.innerHTML+=SLOT_FB_CSS),a&&a.add(o)}}else e.adoptedStyleSheets.includes(l)||(supportsMutableAdoptedStyleSheets?e.adoptedStyleSheets.push(l):e.adoptedStyleSheets=[...e.adoptedStyleSheets,l]);return o},attachStyles=e=>{const t=e.$cmpMeta$,n=e.$hostElement$,s=t.$flags$,o=createTime("attachStyles",t.$tagName$),l=addStyle(n.shadowRoot?n.shadowRoot:n.getRootNode(),t);10&s&&(n["s-sc"]=l,n.classList.add(l+"-h")),o()},getScopeId=(e,t)=>"sc-"+e.$tagName$,h=(e,t,...n)=>{let s=null,o=null,l=null,a=!1,r=!1;const i=[],c=t=>{for(let n=0;n<t.length;n++)s=t[n],Array.isArray(s)?c(s):null!=s&&"boolean"!=typeof s&&((a="function"!=typeof e&&!isComplexType(s))&&(s=String(s)),a&&r?i[i.length-1].$text$+=s:i.push(a?newVNode(null,s):s),r=a)};if(c(n),t){t.key&&(o=t.key),t.name&&(l=t.name);{const e=t.className||t.class;e&&(t.class="object"!=typeof e?e:Object.keys(e).filter(t=>e[t]).join(" "))}}if("function"==typeof e)return e(null===t?{}:t,i,vdomFnUtils);const $=newVNode(e,null);return $.$attrs$=t,i.length>0&&($.$children$=i),$.$key$=o,$.$name$=l,$},newVNode=(e,t)=>({$flags$:0,$tag$:e,$text$:t,$elm$:null,$children$:null,$attrs$:null,$key$:null,$name$:null}),Host={},isHost=e=>e&&e.$tag$===Host,vdomFnUtils={forEach:(e,t)=>e.map(convertToPublic).forEach(t),map:(e,t)=>e.map(convertToPublic).map(t).map(convertToPrivate)},convertToPublic=e=>({vattrs:e.$attrs$,vchildren:e.$children$,vkey:e.$key$,vname:e.$name$,vtag:e.$tag$,vtext:e.$text$}),convertToPrivate=e=>{if("function"==typeof e.vtag){const t={...e.vattrs};return e.vkey&&(t.key=e.vkey),e.vname&&(t.name=e.vname),h(e.vtag,t,...e.vchildren||[])}const t=newVNode(e.vtag,e.vtext);return t.$attrs$=e.vattrs,t.$children$=e.vchildren,t.$key$=e.vkey,t.$name$=e.vname,t},createSupportsRuleRe=e=>{const t=escapeRegExpSpecialCharacters(e);return new RegExp(`(^|[^@]|@(?!supports\\s+selector\\s*\\([^{]*?${t}))(${t}\\b)`,"g")};createSupportsRuleRe("::slotted"),createSupportsRuleRe(":host"),createSupportsRuleRe(":host-context");var contentRef,hostTagName,parsePropertyValue=(e,t,n)=>null==e||isComplexType(e)?e:4&t?"false"!==e&&(""===e||!!e):2&t?"string"==typeof e?parseFloat(e):"number"==typeof e?e:NaN:1&t?String(e):e,getElement=e=>{var t;return null==(t=getHostRef(e))?void 0:t.$hostElement$},createEvent=(e,t,n)=>{const s=getElement(e);return{emit:e=>emitEvent(s,t,{bubbles:!0,composed:!0,cancelable:!0,detail:e})}},emitEvent=(e,t,n)=>{const s=plt.ce(t,n);return e.dispatchEvent(s),s},setAccessor=(e,t,n,s,o,l,a)=>{if(n===s)return;let r=isMemberInElement(e,t),i=t.toLowerCase();if("class"===t){const t=e.classList,o=parseClassList(n);let l=parseClassList(s);t.remove(...o.filter(e=>e&&!l.includes(e))),t.add(...l.filter(e=>e&&!o.includes(e)))}else if("style"===t){for(const t in n)s&&null!=s[t]||(t.includes("-")?e.style.removeProperty(t):e.style[t]="");for(const t in s)n&&s[t]===n[t]||(t.includes("-")?e.style.setProperty(t,s[t]):e.style[t]=s[t])}else if("key"===t);else if("ref"===t)s&&s(e);else if(r||"o"!==t[0]||"n"!==t[1]){const a=isComplexType(s);if((r||a&&null!==s)&&!o)try{if(e.tagName.includes("-"))e[t]!==s&&(e[t]=s);else{const o=null==s?"":s;"list"===t?r=!1:null!=n&&e[t]==o||("function"==typeof e.__lookupSetter__(t)?e[t]=o:e.setAttribute(t,o))}}catch(e){}let c=!1;i!==(i=i.replace(/^xlink\:?/,""))&&(t=i,c=!0),null==s||!1===s?!1===s&&""!==e.getAttribute(t)||(c?e.removeAttributeNS(XLINK_NS,t):e.removeAttribute(t)):(!r||4&l||o)&&!a&&1===e.nodeType&&(s=!0===s?"":s,c?e.setAttributeNS(XLINK_NS,t,s):e.setAttribute(t,s))}else if(t="-"===t[2]?t.slice(3):isMemberInElement(win,i)?i.slice(2):i[2]+t.slice(3),n||s){const o=t.endsWith(CAPTURE_EVENT_SUFFIX);t=t.replace(CAPTURE_EVENT_REGEX,""),n&&plt.rel(e,t,n,o),s&&plt.ael(e,t,s,o)}},parseClassListRegex=/\s/,parseClassList=e=>("object"==typeof e&&e&&"baseVal"in e&&(e=e.baseVal),e&&"string"==typeof e?e.split(parseClassListRegex):[]),CAPTURE_EVENT_SUFFIX="Capture",CAPTURE_EVENT_REGEX=new RegExp(CAPTURE_EVENT_SUFFIX+"$"),updateElement=(e,t,n,s)=>{const o=11===t.$elm$.nodeType&&t.$elm$.host?t.$elm$.host:t.$elm$,l=e&&e.$attrs$||{},a=t.$attrs$||{};for(const e of sortedAttrNames(Object.keys(l)))e in a||setAccessor(o,e,l[e],void 0,n,t.$flags$);for(const e of sortedAttrNames(Object.keys(a)))setAccessor(o,e,l[e],a[e],n,t.$flags$)};function sortedAttrNames(e){return e.includes("ref")?[...e.filter(e=>"ref"!==e),"ref"]:e}var useNativeShadowDom=!1,checkSlotFallbackVisibility=!1,checkSlotRelocate=!1,isSvgMode=!1,createElm=(e,t,n)=>{var s;const o=t.$children$[n];let l,a,r,i=0;if(useNativeShadowDom||(checkSlotRelocate=!0,"slot"===o.$tag$&&(o.$flags$|=o.$children$?2:1)),null!==o.$text$)l=o.$elm$=win.document.createTextNode(o.$text$);else if(1&o.$flags$)l=o.$elm$=win.document.createTextNode(""),updateElement(null,o,isSvgMode);else{if(isSvgMode||(isSvgMode="svg"===o.$tag$),!win.document)throw new Error("You are trying to render a Stencil component in an environment that doesn't support the DOM. Make sure to populate the [`window`](https://developer.mozilla.org/en-US/docs/Web/API/Window/window) object before rendering a component.");if(l=o.$elm$=win.document.createElementNS(isSvgMode?SVG_NS:HTML_NS,!useNativeShadowDom&&BUILD.slotRelocation&&2&o.$flags$?"slot-fb":o.$tag$),isSvgMode&&"foreignObject"===o.$tag$&&(isSvgMode=!1),updateElement(null,o,isSvgMode),o.$children$)for(i=0;i<o.$children$.length;++i)a=createElm(e,o,i),a&&l.appendChild(a);"svg"===o.$tag$?isSvgMode=!1:"foreignObject"===l.tagName&&(isSvgMode=!0)}return l["s-hn"]=hostTagName,3&o.$flags$&&(l["s-sr"]=!0,l["s-cr"]=contentRef,l["s-sn"]=o.$name$||"",l["s-rf"]=null==(s=o.$attrs$)?void 0:s.ref,patchSlotNode(l),r=e&&e.$children$&&e.$children$[n],r&&r.$tag$===o.$tag$&&e.$elm$&&putBackInOriginalLocation(e.$elm$,!1)),l},putBackInOriginalLocation=(e,t)=>{plt.$flags$|=1;const n=Array.from(e.__childNodes||e.childNodes);for(let e=n.length-1;e>=0;e--){const s=n[e];s["s-hn"]!==hostTagName&&s["s-ol"]&&(insertBefore(referenceNode(s).parentNode,s,referenceNode(s)),s["s-ol"].remove(),s["s-ol"]=void 0,s["s-sh"]=void 0,checkSlotRelocate=!0),t&&putBackInOriginalLocation(s,t)}plt.$flags$&=-2},addVnodes=(e,t,n,s,o,l)=>{let a,r=e["s-cr"]&&e["s-cr"].parentNode||e;for(r.shadowRoot&&r.tagName===hostTagName&&(r=r.shadowRoot);o<=l;++o)s[o]&&(a=createElm(null,n,o),a&&(s[o].$elm$=a,insertBefore(r,a,referenceNode(t))))},removeVnodes=(e,t,n)=>{for(let s=t;s<=n;++s){const t=e[s];if(t){const e=t.$elm$;nullifyVNodeRefs(t),e&&(checkSlotFallbackVisibility=!0,e["s-ol"]?e["s-ol"].remove():putBackInOriginalLocation(e,!0),e.remove())}}},updateChildren=(e,t,n,s,o=!1)=>{let l,a,r=0,i=0,c=0,$=0,d=t.length-1,u=t[0],p=t[d],h=s.length-1,m=s[0],f=s[h];for(;r<=d&&i<=h;)if(null==u)u=t[++r];else if(null==p)p=t[--d];else if(null==m)m=s[++i];else if(null==f)f=s[--h];else if(isSameVnode(u,m,o))patch(u,m,o),u=t[++r],m=s[++i];else if(isSameVnode(p,f,o))patch(p,f,o),p=t[--d],f=s[--h];else if(isSameVnode(u,f,o))"slot"!==u.$tag$&&"slot"!==f.$tag$||putBackInOriginalLocation(u.$elm$.parentNode,!1),patch(u,f,o),insertBefore(e,u.$elm$,p.$elm$.nextSibling),u=t[++r],f=s[--h];else if(isSameVnode(p,m,o))"slot"!==u.$tag$&&"slot"!==f.$tag$||putBackInOriginalLocation(p.$elm$.parentNode,!1),patch(p,m,o),insertBefore(e,p.$elm$,u.$elm$),p=t[--d],m=s[++i];else{for(c=-1,$=r;$<=d;++$)if(t[$]&&null!==t[$].$key$&&t[$].$key$===m.$key$){c=$;break}c>=0?(a=t[c],a.$tag$!==m.$tag$?l=createElm(t&&t[i],n,c):(patch(a,m,o),t[c]=void 0,l=a.$elm$),m=s[++i]):(l=createElm(t&&t[i],n,i),m=s[++i]),l&&insertBefore(referenceNode(u.$elm$).parentNode,l,referenceNode(u.$elm$))}r>d?addVnodes(e,null==s[h+1]?null:s[h+1].$elm$,n,s,i,h):i>h&&removeVnodes(t,r,d)},isSameVnode=(e,t,n=!1)=>e.$tag$===t.$tag$&&("slot"===e.$tag$?e.$name$===t.$name$:n?(n&&!e.$key$&&t.$key$&&(e.$key$=t.$key$),!0):e.$key$===t.$key$),referenceNode=e=>e&&e["s-ol"]||e,patch=(e,t,n=!1)=>{const s=t.$elm$=e.$elm$,o=e.$children$,l=t.$children$,a=t.$tag$,r=t.$text$;let i;null===r?(updateElement(e,t,isSvgMode="svg"===a||"foreignObject"!==a&&isSvgMode),null!==o&&null!==l?updateChildren(s,o,t,l,n):null!==l?(null!==e.$text$&&(s.textContent=""),addVnodes(s,null,t,l,0,l.length-1)):!n&&BUILD.updatable&&null!==o&&removeVnodes(o,0,o.length-1),isSvgMode&&"svg"===a&&(isSvgMode=!1)):(i=s["s-cr"])?i.parentNode.textContent=r:e.$text$!==r&&(s.data=r)},relocateNodes=[],markSlotContentForRelocation=e=>{let t,n,s;const o=e.__childNodes||e.childNodes;for(const e of o){if(e["s-sr"]&&(t=e["s-cr"])&&t.parentNode){n=t.parentNode.__childNodes||t.parentNode.childNodes;const o=e["s-sn"];for(s=n.length-1;s>=0;s--)if(t=n[s],!t["s-cn"]&&!t["s-nr"]&&t["s-hn"]!==e["s-hn"])if(isNodeLocatedInSlot(t,o)){let n=relocateNodes.find(e=>e.$nodeToRelocate$===t);checkSlotFallbackVisibility=!0,t["s-sn"]=t["s-sn"]||o,n?(n.$nodeToRelocate$["s-sh"]=e["s-hn"],n.$slotRefNode$=e):(t["s-sh"]=e["s-hn"],relocateNodes.push({$slotRefNode$:e,$nodeToRelocate$:t})),t["s-sr"]&&relocateNodes.map(e=>{isNodeLocatedInSlot(e.$nodeToRelocate$,t["s-sn"])&&(n=relocateNodes.find(e=>e.$nodeToRelocate$===t),n&&!e.$slotRefNode$&&(e.$slotRefNode$=n.$slotRefNode$))})}else relocateNodes.some(e=>e.$nodeToRelocate$===t)||relocateNodes.push({$nodeToRelocate$:t})}1===e.nodeType&&markSlotContentForRelocation(e)}},nullifyVNodeRefs=e=>{e.$attrs$&&e.$attrs$.ref&&e.$attrs$.ref(null),e.$children$&&e.$children$.map(nullifyVNodeRefs)},insertBefore=(e,t,n)=>null==e?void 0:e.insertBefore(t,n),renderVdom=(e,t,n=!1)=>{var s,o,l,a;const r=e.$hostElement$,i=e.$cmpMeta$,c=e.$vnode$||newVNode(null,null),$=isHost(t)?t:h(null,null,t);if(hostTagName=r.tagName,i.$attrsToReflect$&&($.$attrs$=$.$attrs$||{},i.$attrsToReflect$.map(([e,t])=>$.$attrs$[t]=r[e])),n&&$.$attrs$)for(const e of Object.keys($.$attrs$))r.hasAttribute(e)&&!["key","ref","style","class"].includes(e)&&($.$attrs$[e]=r[e]);if($.$tag$=null,$.$flags$|=4,e.$vnode$=$,$.$elm$=c.$elm$=r.shadowRoot||r,useNativeShadowDom=!(!(1&i.$flags$)||128&i.$flags$),contentRef=r["s-cr"],checkSlotFallbackVisibility=!1,patch(c,$,n),plt.$flags$|=1,checkSlotRelocate){markSlotContentForRelocation($.$elm$);for(const e of relocateNodes){const t=e.$nodeToRelocate$;if(!t["s-ol"]&&win.document){const e=win.document.createTextNode("");e["s-nr"]=t,insertBefore(t.parentNode,t["s-ol"]=e,t)}}for(const e of relocateNodes){const t=e.$nodeToRelocate$,r=e.$slotRefNode$;if(r){const e=r.parentNode;let n=r.nextSibling;{let l=null==(s=t["s-ol"])?void 0:s.previousSibling;for(;l;){let s=null!=(o=l["s-nr"])?o:null;if(s&&s["s-sn"]===t["s-sn"]&&e===(s.__parentNode||s.parentNode)){for(s=s.nextSibling;s===t||(null==s?void 0:s["s-sr"]);)s=null==s?void 0:s.nextSibling;if(!s||!s["s-nr"]){n=s;break}}l=l.previousSibling}}const a=t.__parentNode||t.parentNode,i=t.__nextSibling||t.nextSibling;(!n&&e!==a||i!==n)&&t!==n&&(!t["s-hn"]&&t["s-ol"]&&(t["s-hn"]=t["s-ol"].parentNode.nodeName),insertBefore(e,t,n),1===t.nodeType&&"SLOT-FB"!==t.tagName&&(t.hidden=null!=(l=t["s-ih"])&&l)),t&&"function"==typeof r["s-rf"]&&r["s-rf"](r)}else 1===t.nodeType&&(n&&(t["s-ih"]=null!=(a=t.hidden)&&a),t.hidden=!0)}}checkSlotFallbackVisibility&&updateFallbackSlotVisibility($.$elm$),plt.$flags$&=-2,relocateNodes.length=0,contentRef=void 0},attachToAncestor=(e,t)=>{if(t&&!e.$onRenderResolve$&&t["s-p"]){const n=t["s-p"].push(new Promise(s=>e.$onRenderResolve$=()=>{t["s-p"].splice(n-1,1),s()}))}},scheduleUpdate=(e,t)=>{if(e.$flags$|=16,4&e.$flags$)return void(e.$flags$|=512);attachToAncestor(e,e.$ancestorComponent$);const n=()=>dispatchHooks(e,t);if(!t)return writeTask(n);queueMicrotask(()=>{n()})},dispatchHooks=(e,t)=>{const n=e.$hostElement$,s=createTime("scheduleUpdate",e.$cmpMeta$.$tagName$),o=e.$lazyInstance$;if(!o)throw new Error(`Can't render component <${n.tagName.toLowerCase()} /> with invalid Stencil runtime! Make sure this imported component is compiled with a \`externalRuntime: true\` flag. For more information, please refer to https://stenciljs.com/docs/custom-elements#externalruntime`);let l;return t?(e.$flags$|=256,e.$queuedListeners$&&(e.$queuedListeners$.map(([e,t])=>safeCall(o,e,t,n)),e.$queuedListeners$=void 0),l=safeCall(o,"componentWillLoad",void 0,n)):l=safeCall(o,"componentWillUpdate",void 0,n),l=enqueue(l,()=>safeCall(o,"componentWillRender",void 0,n)),s(),enqueue(l,()=>updateComponent(e,o,t))},enqueue=(e,t)=>isPromisey(e)?e.then(t).catch(e=>{console.error(e),t()}):t(),isPromisey=e=>e instanceof Promise||e&&e.then&&"function"==typeof e.then,updateComponent=async(e,t,n)=>{var s;const o=e.$hostElement$,l=createTime("update",e.$cmpMeta$.$tagName$),a=o["s-rc"];n&&attachStyles(e);const r=createTime("render",e.$cmpMeta$.$tagName$);callRender(e,t,o,n),a&&(a.map(e=>e()),o["s-rc"]=void 0),r(),l();{const t=null!=(s=o["s-p"])?s:[],n=()=>postUpdateComponent(e);0===t.length?n():(Promise.all(t).then(n),e.$flags$|=4,t.length=0)}},callRender=(e,t,n,s)=>{try{t=t.render(),e.$flags$&=-17,e.$flags$|=2,renderVdom(e,t,s)}catch(t){consoleError(t,e.$hostElement$)}return null},postUpdateComponent=e=>{const t=e.$cmpMeta$.$tagName$,n=e.$hostElement$,s=createTime("postUpdate",t),o=e.$lazyInstance$,l=e.$ancestorComponent$;safeCall(o,"componentDidRender",void 0,n),64&e.$flags$?(safeCall(o,"componentDidUpdate",void 0,n),s()):(e.$flags$|=64,addHydratedFlag(n),safeCall(o,"componentDidLoad",void 0,n),s(),e.$onReadyResolve$(n),l||appDidLoad()),e.$onInstanceResolve$(n),e.$onRenderResolve$&&(e.$onRenderResolve$(),e.$onRenderResolve$=void 0),512&e.$flags$&&nextTick(()=>scheduleUpdate(e,!1)),e.$flags$&=-517},appDidLoad=e=>{nextTick(()=>emitEvent(win,"appload",{detail:{namespace:NAMESPACE}}))},safeCall=(e,t,n,s)=>{if(e&&e[t])try{return e[t](n)}catch(e){consoleError(e,s)}},addHydratedFlag=e=>{var t;return e.classList.add(null!=(t=BUILD.hydratedSelectorName)?t:"hydrated")},getValue=(e,t)=>getHostRef(e).$instanceValues$.get(t),setValue=(e,t,n,s)=>{const o=getHostRef(e);if(!o)return;if(!o)throw new Error(`Couldn't find host element for "${s.$tagName$}" as it is unknown to this Stencil runtime. This usually happens when integrating a 3rd party Stencil component with another Stencil component or application. Please reach out to the maintainers of the 3rd party Stencil component or report this on the Stencil Discord server (https://chat.stenciljs.com) or comment on this similar [GitHub issue](https://github.com/stenciljs/core/issues/5457).`);const l=o.$hostElement$,a=o.$instanceValues$.get(t),r=o.$flags$,i=o.$lazyInstance$;n=parsePropertyValue(n,s.$members$[t][0]);const c=Number.isNaN(a)&&Number.isNaN(n);if((!(8&r)||void 0===a)&&n!==a&&!c&&(o.$instanceValues$.set(t,n),i)){if(s.$watchers$&&128&r){const e=s.$watchers$[t];e&&e.map(e=>{try{i[e](n,a,t)}catch(e){consoleError(e,l)}})}if(2==(18&r)){if(i.componentShouldUpdate&&!1===i.componentShouldUpdate(n,a,t))return;scheduleUpdate(o,!1)}}},proxyComponent=(e,t,n)=>{var s,o;const l=e.prototype;if(t.$members$||t.$watchers$||e.watchers){e.watchers&&!t.$watchers$&&(t.$watchers$=e.watchers);const a=Object.entries(null!=(s=t.$members$)?s:{});if(a.map(([e,[s]])=>{if(31&s||2&n&&32&s){const{get:o,set:a}=Object.getOwnPropertyDescriptor(l,e)||{};o&&(t.$members$[e][0]|=2048),a&&(t.$members$[e][0]|=4096),(1&n||!o)&&Object.defineProperty(l,e,{get(){{if(!(2048&t.$members$[e][0]))return getValue(this,e);const n=getHostRef(this),s=n?n.$lazyInstance$:l;if(!s)return;return s[e]}},configurable:!0,enumerable:!0}),Object.defineProperty(l,e,{set(o){const l=getHostRef(this);if(l){if(a){const n=32&s?this[e]:l.$hostElement$[e];return void 0===n&&l.$instanceValues$.get(e)?o=l.$instanceValues$.get(e):!l.$instanceValues$.get(e)&&n&&l.$instanceValues$.set(e,n),a.apply(this,[parsePropertyValue(o,s)]),o=32&s?this[e]:l.$hostElement$[e],void setValue(this,e,o,t)}{if(!(1&n&&4096&t.$members$[e][0]))return setValue(this,e,o,t),void(1&n&&!l.$lazyInstance$&&l.$onReadyPromise$.then(()=>{4096&t.$members$[e][0]&&l.$lazyInstance$[e]!==l.$instanceValues$.get(e)&&(l.$lazyInstance$[e]=o)}));const a=()=>{const n=l.$lazyInstance$[e];!l.$instanceValues$.get(e)&&n&&l.$instanceValues$.set(e,n),l.$lazyInstance$[e]=parsePropertyValue(o,s),setValue(this,e,l.$lazyInstance$[e],t)};l.$lazyInstance$?a():l.$onReadyPromise$.then(()=>a())}}}})}else 1&n&&64&s&&Object.defineProperty(l,e,{value(...t){var n;const s=getHostRef(this);return null==(n=null==s?void 0:s.$onInstancePromise$)?void 0:n.then(()=>{var n;return null==(n=s.$lazyInstance$)?void 0:n[e](...t)})}})}),1&n){const n=new Map;l.attributeChangedCallback=function(e,s,o){plt.jmp(()=>{var a;const r=n.get(e);if(this.hasOwnProperty(r)&&BUILD.lazyLoad)o=this[r],delete this[r];else{if(l.hasOwnProperty(r)&&"number"==typeof this[r]&&this[r]==o)return;if(null==r){const n=getHostRef(this),l=null==n?void 0:n.$flags$;if(n&&l&&!(8&l)&&128&l&&o!==s){const l=n.$lazyInstance$,r=null==(a=t.$watchers$)?void 0:a[e];null==r||r.forEach(t=>{null!=l[t]&&l[t].call(l,o,s,e)})}return}}const i=Object.getOwnPropertyDescriptor(l,r);(o=(null!==o||"boolean"!=typeof this[r])&&o)===this[r]||i.get&&!i.set||(this[r]=o)})},e.observedAttributes=Array.from(new Set([...Object.keys(null!=(o=t.$watchers$)?o:{}),...a.filter(([e,t])=>15&t[0]).map(([e,s])=>{var o;const l=s[1]||e;return n.set(l,e),512&s[0]&&(null==(o=t.$attrsToReflect$)||o.push([e,l])),l})]))}}return e},initializeComponent=async(e,t,n,s)=>{let o;if(!(32&t.$flags$)){if(t.$flags$|=32,n.$lazyBundleId$){const s=loadModule(n,t);if(s&&"then"in s){const e=uniqueTime();o=await s,e()}else o=s;if(!o)throw new Error(`Constructor for "${n.$tagName$}#${t.$modeName$}" was not found`);o.isProxied||(n.$watchers$=o.watchers,proxyComponent(o,n,2),o.isProxied=!0);const l=createTime("createInstance",n.$tagName$);t.$flags$|=8;try{new o(t)}catch(t){consoleError(t,e)}t.$flags$&=-9,t.$flags$|=128,l(),fireConnectedCallback(t.$lazyInstance$,e)}else{o=e.constructor;const n=e.localName;customElements.whenDefined(n).then(()=>t.$flags$|=128)}if(o&&o.style){let e;"string"==typeof o.style&&(e=o.style);const t=getScopeId(n);if(!styles.has(t)){const s=createTime("registerStyles",n.$tagName$);registerStyle(t,e,!!(1&n.$flags$)),s()}}}const l=t.$ancestorComponent$,a=()=>scheduleUpdate(t,!0);l&&l["s-rc"]?l["s-rc"].push(a):a()},fireConnectedCallback=(e,t)=>{safeCall(e,"connectedCallback",void 0,t)},connectedCallback=e=>{if(!(1&plt.$flags$)){const t=getHostRef(e);if(!t)return;const n=t.$cmpMeta$,s=createTime("connectedCallback",n.$tagName$);if(1&t.$flags$)addHostEventListeners(e,t,n.$listeners$),(null==t?void 0:t.$lazyInstance$)?fireConnectedCallback(t.$lazyInstance$,e):(null==t?void 0:t.$onReadyPromise$)&&t.$onReadyPromise$.then(()=>fireConnectedCallback(t.$lazyInstance$,e));else{t.$flags$|=1,12&n.$flags$&&setContentReference(e);{let n=e;for(;n=n.parentNode||n.host;)if(n["s-p"]){attachToAncestor(t,t.$ancestorComponent$=n);break}}n.$members$&&Object.entries(n.$members$).map(([t,[n]])=>{if(31&n&&e.hasOwnProperty(t)){const n=e[t];delete e[t],e[t]=n}}),initializeComponent(e,t,n)}s()}},setContentReference=e=>{if(!win.document)return;const t=e["s-cr"]=win.document.createComment("");t["s-cn"]=!0,insertBefore(e,t,e.firstChild)},disconnectInstance=(e,t)=>{safeCall(e,"disconnectedCallback",void 0,t||e)},disconnectedCallback=async e=>{if(!(1&plt.$flags$)){const t=getHostRef(e);(null==t?void 0:t.$rmListeners$)&&(t.$rmListeners$.map(e=>e()),t.$rmListeners$=void 0),(null==t?void 0:t.$lazyInstance$)?disconnectInstance(t.$lazyInstance$,e):(null==t?void 0:t.$onReadyPromise$)&&t.$onReadyPromise$.then(()=>disconnectInstance(t.$lazyInstance$,e))}rootAppliedStyles.has(e)&&rootAppliedStyles.delete(e),e.shadowRoot&&rootAppliedStyles.has(e.shadowRoot)&&rootAppliedStyles.delete(e.shadowRoot)},bootstrapLazy=(e,t={})=>{var n;if(!win.document)return void console.warn("Stencil: No document found. Skipping bootstrapping lazy components.");const s=createTime(),o=[],l=t.exclude||[],a=win.customElements,r=win.document.head,i=r.querySelector("meta[charset]"),c=win.document.createElement("style"),$=[];let d,u=!0;Object.assign(plt,t),plt.$resourcesUrl$=new URL(t.resourcesUrl||"./",win.document.baseURI).href;let p=!1;if(e.map(e=>{e[1].map(t=>{var n;const s={$flags$:t[0],$tagName$:t[1],$members$:t[2],$listeners$:t[3]};4&s.$flags$&&(p=!0),s.$members$=t[2],s.$listeners$=t[3],s.$attrsToReflect$=[],s.$watchers$=null!=(n=t[4])?n:{};const r=s.$tagName$,i=class extends HTMLElement{constructor(e){if(super(e),this.hasRegisteredEventListeners=!1,registerHost(e=this,s),1&s.$flags$)if(e.shadowRoot){if("open"!==e.shadowRoot.mode)throw new Error(`Unable to re-use existing shadow root for ${s.$tagName$}! Mode is set to ${e.shadowRoot.mode} but Stencil only supports open shadow roots.`)}else createShadowRoot.call(e,s)}connectedCallback(){const e=getHostRef(this);e&&(this.hasRegisteredEventListeners||(this.hasRegisteredEventListeners=!0,addHostEventListeners(this,e,s.$listeners$)),d&&(clearTimeout(d),d=null),u?$.push(this):plt.jmp(()=>connectedCallback(this)))}disconnectedCallback(){plt.jmp(()=>disconnectedCallback(this)),plt.raf(()=>{var e;const t=getHostRef(this);if(!t)return;const n=$.findIndex(e=>e===this);n>-1&&$.splice(n,1),(null==(e=null==t?void 0:t.$vnode$)?void 0:e.$elm$)instanceof Node&&!t.$vnode$.$elm$.isConnected&&delete t.$vnode$.$elm$})}componentOnReady(){var e;return null==(e=getHostRef(this))?void 0:e.$onReadyPromise$}};s.$lazyBundleId$=e[0],l.includes(r)||a.get(r)||(o.push(r),a.define(r,proxyComponent(i,s,1)))})}),o.length>0&&(p&&(c.textContent+=SLOT_FB_CSS),c.textContent+=o.sort()+HYDRATED_CSS,c.innerHTML.length)){c.setAttribute("data-styles","");const e=null!=(n=plt.$nonce$)?n:queryNonceMetaTagContent(win.document);null!=e&&c.setAttribute("nonce",e),r.insertBefore(c,i?i.nextSibling:r.firstChild)}u=!1,$.length?$.map(e=>e.connectedCallback()):plt.jmp(()=>d=setTimeout(appDidLoad,30)),s()},addHostEventListeners=(e,t,n,s)=>{n&&win.document&&n.map(([n,s,o])=>{const l=getHostListenerTarget(win.document,e,n),a=hostListenerProxy(t,o),r=hostListenerOpts(n);plt.ael(l,s,a,r),(t.$rmListeners$=t.$rmListeners$||[]).push(()=>plt.rel(l,s,a,r))})},hostListenerProxy=(e,t)=>n=>{var s;try{256&e.$flags$?null==(s=e.$lazyInstance$)||s[t](n):(e.$queuedListeners$=e.$queuedListeners$||[]).push([t,n])}catch(t){consoleError(t,e.$hostElement$)}},getHostListenerTarget=(e,t,n)=>8&n?win:t,hostListenerOpts=e=>supportsListenerOptions?{passive:!!(1&e),capture:!!(2&e)}:!!(2&e),setNonce=e=>plt.$nonce$=e;export{Host as H,getElement as a,bootstrapLazy as b,createEvent as c,globalScripts as g,h,promiseResolve as p,registerInstance as r,setNonce as s};